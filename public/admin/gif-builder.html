<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GIF Builder - Admin AdrianLAB</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 32px;
    }
    
    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 14px;
    }
    
    .main-layout {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 30px;
      margin-bottom: 30px;
    }
    
    .config-panel, .preview-panel {
      background: #f9fafb;
      border-radius: 8px;
      padding: 20px;
    }
    
    .section {
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 1px solid #e5e7eb;
    }
    
    .section:last-child {
      border-bottom: none;
    }
    
    .section-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      color: #374151;
      font-weight: 500;
      font-size: 14px;
    }
    
    select, input {
      width: 100%;
      padding: 10px;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      font-size: 14px;
      transition: border-color 0.2s;
    }
    
    select:focus, input:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .list-item {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .list-item input {
      flex: 1;
      margin: 0;
    }
    
    .btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-primary {
      background: #667eea;
      color: white;
    }
    
    .btn-primary:hover {
      background: #5568d3;
    }
    
    .btn-secondary {
      background: #6b7280;
      color: white;
    }
    
    .btn-secondary:hover {
      background: #4b5563;
    }
    
    .btn-danger {
      background: #ef4444;
      color: white;
    }
    
    .btn-danger:hover {
      background: #dc2626;
    }
    
    .btn-small {
      padding: 4px 8px;
      font-size: 12px;
    }
    
    .btn-icon {
      padding: 6px;
      width: 32px;
      height: 32px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    
    .movement-config {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 6px;
      padding: 15px;
      margin-bottom: 15px;
    }
    
    .movement-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .movement-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: #cbd5e1;
      border-radius: 12px;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .toggle-switch.active {
      background: #667eea;
    }
    
    .toggle-switch::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    
    .toggle-switch.active::after {
      transform: translateX(20px);
    }
    
    .preview-area {
      background: white;
      border: 2px dashed #e5e7eb;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      min-height: 300px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .preview-area img {
      max-width: 100%;
      max-height: 400px;
      border-radius: 8px;
    }
    
    .preview-info {
      margin-top: 20px;
      text-align: left;
      width: 100%;
    }
    
    .info-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid #e5e7eb;
      font-size: 14px;
    }
    
    .info-item:last-child {
      border-bottom: none;
    }
    
    .url-display {
      background: #1f2937;
      color: #10b981;
      padding: 15px;
      border-radius: 6px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      word-break: break-all;
      margin-bottom: 15px;
      max-height: 150px;
      overflow-y: auto;
    }
    
    .url-actions {
      display: flex;
      gap: 10px;
    }
    
    .btn-full {
      flex: 1;
    }
    
    .error {
      background: #fee2e2;
      color: #991b1b;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
      font-size: 14px;
    }
    
    .success {
      background: #d1fae5;
      color: #065f46;
      padding: 12px;
      border-radius: 6px;
      margin-bottom: 15px;
      font-size: 14px;
    }
    
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #f3f4f6;
      border-top-color: #667eea;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .drag-handle {
      cursor: move;
      color: #9ca3af;
    }
    
    .drag-handle:hover {
      color: #667eea;
    }
    
    .frame-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      padding: 10px;
      background: #f3f4f6;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .frame-checkbox {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
    }
    
    .frame-checkbox:hover {
      border-color: #667eea;
      background: #f0f4ff;
    }
    
    .frame-checkbox input[type="checkbox"] {
      width: auto;
      margin: 0;
      cursor: pointer;
    }
    
    .frame-checkbox.selected {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }
    
    .total-frames-control {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .total-frames-control input {
      width: 80px;
    }
    
    .trait-frame-config {
      margin-top: 10px;
      padding: 10px;
      background: #f9fafb;
      border-radius: 6px;
      border: 1px solid #e5e7eb;
    }
    
    .trait-frame-config-title {
      font-size: 12px;
      font-weight: 600;
      color: #6b7280;
      margin-bottom: 8px;
    }
    
    .quick-select-buttons {
      display: flex;
      gap: 5px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    
    .quick-select-btn {
      padding: 4px 8px;
      font-size: 11px;
      border: 1px solid #d1d5db;
      background: white;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .quick-select-btn:hover {
      background: #f3f4f6;
    }
    
    @media (max-width: 1024px) {
      .main-layout {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <div>
        <h1>üé¨ GIF Builder</h1>
        <p class="subtitle">Visual builder to generate animated GIFs with skins, traits and movements</p>
      </div>
      <a href="/admin" class="btn btn-secondary" style="text-decoration: none; margin-top: 10px;">‚Üê Admin Panel</a>
    </div>
    
    <div class="main-layout">
      <!-- Panel de Configuraci√≥n -->
      <div class="config-panel">
        <!-- Version -->
        <div class="section">
          <div class="section-title">üìå API Version</div>
          <div class="form-group">
            <select id="version">
              <option value="v1">v1 (test-gif-simple) - Stable</option>
              <option value="v2" selected>v2 (test-gif-simple-v2) - Latest</option>
              <option value="v3">v3 (test-gif-simple-v3) - SVG Controls</option>
            </select>
          </div>
        </div>
        
        <!-- Method -->
        <div class="section">
          <div class="section-title">‚öôÔ∏è Render Method</div>
          <div class="form-group">
            <select id="method">
              <option value="gifwrap">gifwrap (Recommended)</option>
              <option value="sharp">sharp (Fast)</option>
            </select>
          </div>
        </div>
        
        <!-- AdrianZERO Base (v3 only) -->
        <div class="section" id="adrianzero-section" style="display: none;">
          <div class="section-title">üéØ AdrianZERO Base (v3)</div>
          <div class="form-group">
            <label>Token ID:</label>
            <input type="text" id="adrianzero-tokenid" placeholder="e.g. 146" 
                   onchange="updateAdrianZeroTokenId(this.value)">
            <p style="font-size: 11px; color: #6b7280; margin-top: 5px;">
              Renderiza un AdrianZERO completo como base (bajo del todo)
            </p>
          </div>
        </div>
        
        <!-- Base Skin -->
        <div class="section">
          <div class="section-title">üé® Base Skin</div>
          <div class="form-group">
            <select id="base">
              <option value="">None</option>
              <option value="medium">Medium</option>
              <option value="dark">Dark / DarkAdrian</option>
              <option value="alien">Alien</option>
              <option value="albino">Albino</option>
              <option value="adriangf">AdrianGF (Fair)</option>
              <option value="adriangf-tan">AdrianGF (Tan)</option>
              <option value="adriangf-albino">AdrianGF (Albino)</option>
              <option value="blankmannequin">Blank Mannequin</option>
              <option value="mannequin">Mannequin</option>
            </select>
          </div>
        </div>
        
        <!-- Fixed Traits -->
        <div class="section">
          <div class="section-title">üìå Fixed Traits (Still)</div>
          <div id="fixed-traits-list"></div>
          <button class="btn btn-primary btn-small" onclick="addFixedTrait()">+ Add Fixed Trait</button>
        </div>
        
        <!-- Total Frames Control -->
        <div class="section">
          <div class="section-title">üéûÔ∏è Total Frames</div>
          <div class="total-frames-control">
            <label>Number of frames:</label>
            <input type="number" id="total-frames" value="10" min="1" max="100" 
                   onchange="updateTotalFrames(parseInt(this.value))">
          </div>
        </div>
        
        <!-- Animated Traits -->
        <div class="section">
          <div class="section-title">üé¨ Animated Traits</div>
          <p style="font-size: 12px; color: #6b7280; margin-bottom: 10px;">
            Enter base trait ID (e.g. "1166") - variants (1166a, 1166b, etc.) will be auto-detected
          </p>
          <div id="animated-traits-list"></div>
          <button class="btn btn-primary btn-small" onclick="addAnimatedTrait()">+ Add Animated Trait</button>
        </div>
        
        <!-- Variable Frames / Traits -->
        <div class="section">
          <div class="section-title">üéûÔ∏è Variable Traits (Frame-based)</div>
          <div id="frames-list"></div>
          <button class="btn btn-primary btn-small" onclick="addFrame()">+ Add Trait</button>
        </div>
        
        <!-- Movements -->
        <div class="section">
          <div class="section-title">üé≠ Movements</div>
          <div id="movements-list"></div>
          <button class="btn btn-primary btn-small" onclick="addMovement()">+ Add Movement</button>
          <p style="font-size: 12px; color: #6b7280; margin-top: 10px;">
            üí° Tip: Movements can be applied to specific frames by configuring the trait's frame selection above.
          </p>
        </div>
        
        <!-- Bounce Animation -->
        <div class="section">
          <div class="section-title">‚ö° Bounce Animation</div>
          <p style="font-size: 12px; color: #6b7280; margin-bottom: 15px;">
            Apply bounce effect: skin/base bounces first, traits bounce after with delay
          </p>
          
          <div class="form-group">
            <label>
              <input type="checkbox" id="bounce-enabled" onchange="updateBounceConfig()" style="width: auto; margin-right: 8px;">
              Enable Bounce Animation
            </label>
          </div>
          
          <div id="bounce-config" style="display: none;">
            <div class="form-group">
              <label for="bounce-direction">Direction</label>
              <select id="bounce-direction" onchange="updateBounceConfig()">
                <option value="y">Vertical (Y) - Recommended</option>
                <option value="x">Horizontal (X)</option>
                <option value="both">Both (Diagonal)</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="bounce-distance">Distance (pixels)</label>
              <input type="number" id="bounce-distance" value="50" min="0" max="200" step="5" onchange="updateBounceConfig()">
            </div>
            
            <div class="form-group">
              <label for="bounce-count">Number of Bounces</label>
              <input type="number" id="bounce-count" value="3" min="1" max="10" step="1" onchange="updateBounceConfig()">
            </div>
            
            <div class="form-group">
              <label for="bounce-frames">Total Frames</label>
              <input type="number" id="bounce-frames" value="12" min="4" max="32" step="1" onchange="updateBounceConfig()">
            </div>
            
            <div class="form-group">
              <label for="bounce-delay">Delay Skin ‚Üí Traits (frames)</label>
              <input type="number" id="bounce-delay" value="2" min="0" max="8" step="1" onchange="updateBounceConfig()">
              <p style="font-size: 11px; color: #6b7280; margin-top: 4px;">
                How many frames delay between skin bounce and traits bounce
              </p>
            </div>
            
            <div style="background: #f0f4ff; padding: 10px; border-radius: 6px; margin-top: 10px; font-size: 12px; color: #4b5563;">
              <strong>Sync Info:</strong>
              <div id="bounce-sync-info" style="margin-top: 5px;">-</div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Panel de Preview -->
      <div class="preview-panel">
        <div class="section-title">üëÅÔ∏è Preview</div>
        <div class="preview-area" id="preview-area">
          <p style="color: #9ca3af;">Generate a preview to see the result</p>
        </div>
        <button class="btn btn-primary btn-full" onclick="generatePreview()" style="margin-top: 15px;">
          üé¨ Generate Preview
        </button>
        
        <div class="preview-info" id="preview-info" style="display: none;">
          <div class="info-item">
            <span>Frames:</span>
            <span id="info-frames">-</span>
          </div>
          <div class="info-item">
            <span>Total Duration:</span>
            <span id="info-duration">-</span>
          </div>
          <div class="info-item">
            <span>Size:</span>
            <span id="info-size">-</span>
          </div>
          <div class="info-item">
            <span>Layers per Frame:</span>
            <span id="info-layers">-</span>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Generated URL -->
    <div class="section">
      <div class="section-title">üîó Generated URL</div>
      <div class="url-display" id="url-display">Configure parameters to generate the URL...</div>
      <div class="url-actions">
        <button class="btn btn-primary btn-full" onclick="copyURL()">üìã Copy URL</button>
        <button class="btn btn-secondary btn-full" onclick="openURL()">üîó Open in New Tab</button>
      </div>
    </div>
    
    <!-- Mensajes -->
    <div id="message-area"></div>
  </div>
  
  <script>
    // Builder state
    let builderState = {
      version: 'v2',
      method: 'gifwrap',
      base: '',
      fixed: [],
      frames: [],
      animatedTraits: [], // [{ baseId: '1166', variants: ['1166a', '1166b', ...], delay: 500 }]
      movements: [],
      totalFrames: 10, // Total frames for the animation
      frameConfigs: {}, // Configurations per trait: { 'traitId': { frames: [1,2,3], movements: {...} } }
      adrianZeroTokenId: '', // AdrianZERO tokenId for v3
      bounceConfig: {
        enabled: false,
        direction: 'y',
        distance: 50,
        bounces: 3,
        frames: 12,
        delay: 2
      }
    };
    
    // Load saved state
    function loadState() {
      const saved = localStorage.getItem('gifBuilderState');
      if (saved) {
        try {
          builderState = JSON.parse(saved);
          // Asegurar que animatedTraits existe (para compatibilidad con estados antiguos)
          if (!builderState.animatedTraits) {
            builderState.animatedTraits = [];
          }
          applyState();
        } catch (e) {
          console.error('Error loading state:', e);
        }
      }
    }
    
    // Save state
    function saveState() {
      localStorage.setItem('gifBuilderState', JSON.stringify(builderState));
    }
    
    // Apply state to UI
    function applyState() {
      document.getElementById('version').value = builderState.version || 'v2';
      document.getElementById('method').value = builderState.method;
      document.getElementById('base').value = builderState.base || '';
      document.getElementById('total-frames').value = builderState.totalFrames || 10;
      document.getElementById('adrianzero-tokenid').value = builderState.adrianZeroTokenId || '';
      
      // Asegurar que bounceConfig existe
      if (!builderState.bounceConfig) {
        builderState.bounceConfig = {
          enabled: false,
          direction: 'y',
          distance: 50,
          bounces: 3,
          frames: 12,
          delay: 2
        };
      }
      
      // Aplicar configuraci√≥n de bounce
      const bounceEnabled = document.getElementById('bounce-enabled');
      const bounceConfig = document.getElementById('bounce-config');
      if (bounceEnabled && bounceConfig) {
        bounceEnabled.checked = builderState.bounceConfig.enabled || false;
        bounceConfig.style.display = bounceEnabled.checked ? 'block' : 'none';
        
        document.getElementById('bounce-direction').value = builderState.bounceConfig.direction || 'y';
        document.getElementById('bounce-distance').value = builderState.bounceConfig.distance || 50;
        document.getElementById('bounce-count').value = builderState.bounceConfig.bounces || 3;
        document.getElementById('bounce-frames').value = builderState.bounceConfig.frames || 12;
        document.getElementById('bounce-delay').value = builderState.bounceConfig.delay || 2;
        
        updateBounceSyncInfo();
      }
      
      // Mostrar/ocultar secci√≥n AdrianZERO seg√∫n versi√≥n
      const adrianZeroSection = document.getElementById('adrianzero-section');
      if (adrianZeroSection) {
        adrianZeroSection.style.display = builderState.version === 'v3' ? 'block' : 'none';
      }
      
      renderFixedTraits();
      renderAnimatedTraits();
      renderFrames();
      renderMovements();
      updateURL();
    }
    
    // Update bounce configuration
    function updateBounceConfig() {
      const enabled = document.getElementById('bounce-enabled').checked;
      const bounceConfig = document.getElementById('bounce-config');
      
      builderState.bounceConfig = {
        enabled: enabled,
        direction: document.getElementById('bounce-direction').value,
        distance: parseFloat(document.getElementById('bounce-distance').value) || 50,
        bounces: parseInt(document.getElementById('bounce-count').value) || 3,
        frames: parseInt(document.getElementById('bounce-frames').value) || 12,
        delay: parseInt(document.getElementById('bounce-delay').value) || 2
      };
      
      bounceConfig.style.display = enabled ? 'block' : 'none';
      updateBounceSyncInfo();
      updateURL();
      saveState();
    }
    
    // Update bounce sync info display
    function updateBounceSyncInfo() {
      const syncInfo = document.getElementById('bounce-sync-info');
      if (!syncInfo || !builderState.bounceConfig.enabled) {
        return;
      }
      
      const { frames, delay } = builderState.bounceConfig;
      const skinFrames = frames;
      const traitsFrames = frames;
      const syncText = `Skin: ${skinFrames} frames (immediate) | Traits: ${traitsFrames} frames (${delay} frame delay)`;
      syncInfo.textContent = syncText;
    }
    
    function updateAdrianZeroTokenId(value) {
      builderState.adrianZeroTokenId = value;
      updateURL();
      saveState();
    }
    
    // Update version
    function updateVersion() {
      builderState.version = document.getElementById('version').value;
      
      // Mostrar/ocultar secci√≥n AdrianZERO seg√∫n versi√≥n
      const adrianZeroSection = document.getElementById('adrianzero-section');
      if (adrianZeroSection) {
        adrianZeroSection.style.display = builderState.version === 'v3' ? 'block' : 'none';
      }
      
      updateURL();
      saveState();
    }
    
    // Render fixed traits
    function renderFixedTraits() {
      const container = document.getElementById('fixed-traits-list');
      container.innerHTML = '';
      
      builderState.fixed.forEach((trait, index) => {
        const frameConfig = builderState.frameConfigs[trait.id] || { frames: [], movements: {} };
        const selectedFrames = frameConfig.frames || [];
        // Si no hay configuraci√≥n, mostrar en todos los frames por defecto
        const defaultFrames = selectedFrames.length === 0 
          ? Array.from({length: builderState.totalFrames}, (_, i) => i + 1)
          : selectedFrames;
        
        const item = document.createElement('div');
        item.className = 'list-item';
        item.style.flexDirection = 'column';
        item.style.alignItems = 'stretch';
        item.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span class="drag-handle">‚ò∞</span>
            <input type="text" value="${trait.id}" placeholder="Trait ID" 
                   onchange="updateFixedTrait(${index}, this.value)" style="flex: 1;">
            <button class="btn btn-danger btn-small btn-icon" onclick="removeFixedTrait(${index})">√ó</button>
          </div>
          ${trait.id ? `
            <div class="trait-frame-config">
              <div class="trait-frame-config-title">Appears in frames:</div>
              <div class="quick-select-buttons">
                <button class="quick-select-btn" onclick="selectAllFrames('${trait.id}')">All</button>
                <button class="quick-select-btn" onclick="selectNoFrames('${trait.id}')">None</button>
                <button class="quick-select-btn" onclick="selectFirstHalf('${trait.id}')">First Half</button>
                <button class="quick-select-btn" onclick="selectSecondHalf('${trait.id}')">Second Half</button>
              </div>
              <div class="frame-selector" id="frame-selector-${trait.id}">
                ${generateFrameCheckboxes(trait.id, defaultFrames)}
              </div>
            </div>
          ` : ''}
        `;
        container.appendChild(item);
      });
    }
    
    // Render animated traits
    function renderAnimatedTraits() {
      const container = document.getElementById('animated-traits-list');
      container.innerHTML = '';
      
      // Asegurar que animatedTraits existe
      if (!builderState.animatedTraits) {
        builderState.animatedTraits = [];
      }
      
      builderState.animatedTraits.forEach((animTrait, index) => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.style.flexDirection = 'column';
        item.style.alignItems = 'stretch';
        item.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span class="drag-handle">‚ò∞</span>
            <input type="text" value="${animTrait.baseId}" placeholder="Base ID (e.g. 1166)" 
                   onchange="updateAnimatedTraitBase(${index}, this.value)" 
                   onkeyup="if(event.key==='Enter') updateAnimatedTraitBase(${index}, this.value)"
                   style="flex: 1;">
            <input type="number" value="${animTrait.delay || 500}" placeholder="Delay (ms)" min="10" max="5000"
                   onchange="updateAnimatedTraitDelay(${index}, parseInt(this.value))" style="width: 120px;">
            <button class="btn btn-danger btn-small btn-icon" onclick="removeAnimatedTrait(${index})">√ó</button>
          </div>
          ${animTrait.variants && animTrait.variants.length > 0 ? `
            <div class="trait-frame-config">
              <div class="trait-frame-config-title">
                Found ${animTrait.variants.length} variants: ${animTrait.variants.join(', ')}
              </div>
              <div style="font-size: 11px; color: #6b7280; margin-top: 5px;">
                ${builderState.animatedTraits.length > 1 
                  ? 'Combinado simult√°neamente con otros animated traits' 
                  : `Auto-assigned to frames ${animTrait.startFrame || 1} to ${(animTrait.startFrame || 1) + animTrait.variants.length - 1}`}
              </div>
            </div>
          ` : animTrait.baseId ? `
            <div style="font-size: 11px; color: #9ca3af; padding: 5px;">
              Detecting variants...
            </div>
          ` : ''}
        `;
        container.appendChild(item);
      });
      
      // Mostrar informaci√≥n de sincronizaci√≥n si hay m√∫ltiples traits
      const syncInfo = calculateSyncInfo();
      if (syncInfo && builderState.animatedTraits.length > 1) {
        const syncDiv = document.createElement('div');
        syncDiv.style.cssText = 'margin-top: 15px; padding: 10px; background: #f3f4f6; border-radius: 6px; font-size: 12px;';
        syncDiv.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 5px; color: #374151;">üìä Sincronizaci√≥n de Traits:</div>
          <div style="color: ${syncInfo.syncMode === 'perfect' ? '#059669' : '#d97706'}; margin-bottom: 5px;">
            ${syncInfo.message}
          </div>
          ${syncInfo.cycles ? `
            <div style="margin-top: 8px; color: #6b7280;">
              <div style="font-weight: 500; margin-bottom: 3px;">Ciclos por trait:</div>
              ${syncInfo.cycles.map(c => 
                `<div style="margin-left: 10px;">‚Ä¢ Trait ${c.traitId}: ${c.variants} variantes ‚Üí ${c.cycles} ciclos completos</div>`
              ).join('')}
            </div>
          ` : ''}
          ${syncInfo.syncMode === 'cycled' ? `
            <div style="margin-top: 8px; color: #6b7280; font-style: italic;">
              Los traits ciclar√°n independientemente usando m√≥dulo (preserva loops cerrados)
            </div>
          ` : ''}
        `;
        container.appendChild(syncDiv);
      }
      
      // Actualizar total frames basado en animated traits
      updateTotalFramesFromAnimatedTraits();
    }
    
    // Detectar variantes de un trait animado (autom√°tico)
    async function detectAnimatedVariants(index) {
      const animTrait = builderState.animatedTraits[index];
      if (!animTrait || !animTrait.baseId) {
        return;
      }
      
      const baseId = animTrait.baseId.trim();
      if (!baseId) {
        return;
      }
      
      const variants = [];
      const letters = 'abcdefghij'.split(''); // Solo buscar hasta 10 variantes (a-j)
      
      // IMPORTANTE: Solo buscamos variantes con letras (ej: 1165a, 1165b)
      // NO incluimos el archivo base sin letra (ej: 1165.svg) - ese es para otros renders
      const baseUrl = 'https://adrianlab.vercel.app';
      
      // Hacer todas las peticiones en paralelo para mayor velocidad
      const checkPromises = letters.map(async (letter) => {
        const variantId = `${baseId}${letter}`; // Siempre con letra: 1165a, 1165b, etc.
        const url = `${baseUrl}/labimages/${variantId}.svg`;
        
        try {
          const response = await fetch(url, { method: 'HEAD' });
          if (response.ok) {
            return variantId;
          }
        } catch (e) {
          // Ignorar errores
        }
        return null;
      });
      
      const results = await Promise.all(checkPromises);
      // Filtrar resultados y asegurar que solo incluimos variantes con letra
      variants.push(...results.filter(v => v !== null && v !== baseId)); // baseId sin letra nunca deber√≠a estar aqu√≠, pero por seguridad
      
      // Actualizar el trait animado
      animTrait.variants = variants;
      // No calcular startFrame - los animated traits se combinan simult√°neamente, no secuencialmente
      
      renderAnimatedTraits();
      updateURL();
      saveState();
    }
    
    // Calcular GCD (M√°ximo Com√∫n Divisor)
    function calculateGCD(a, b) {
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    }
    
    // Calcular LCM (M√≠nimo Com√∫n M√∫ltiplo) de un array de n√∫meros
    function calculateLCM(numbers) {
      if (numbers.length === 0) return 1;
      if (numbers.length === 1) return numbers[0];
      
      let lcm = numbers[0];
      for (let i = 1; i < numbers.length; i++) {
        lcm = (lcm * numbers[i]) / calculateGCD(lcm, numbers[i]);
      }
      return lcm;
    }
    
    // Calcular informaci√≥n de sincronizaci√≥n para m√∫ltiples traits animados
    function calculateSyncInfo() {
      if (!builderState.animatedTraits || !Array.isArray(builderState.animatedTraits)) {
        return null;
      }
      
      const variantCounts = [];
      let maxVariants = 0;
      
      builderState.animatedTraits.forEach(animTrait => {
        if (animTrait.variants && animTrait.variants.length > 0) {
          variantCounts.push(animTrait.variants.length);
          maxVariants = Math.max(maxVariants, animTrait.variants.length);
        }
      });
      
      if (variantCounts.length === 0) {
        return null;
      }
      
      const MAX_FRAMES_LCM = 15;
      let totalFrames;
      let syncMode;
      let syncInfo;
      
      if (variantCounts.length === 1) {
        totalFrames = variantCounts[0];
        syncMode = 'single';
        syncInfo = { totalFrames, syncMode, message: `Un solo trait: ${totalFrames} frames` };
      } else {
        const lcm = calculateLCM(variantCounts);
        
        if (lcm <= MAX_FRAMES_LCM) {
          totalFrames = lcm;
          syncMode = 'perfect';
          const cycles = variantCounts.map((count, i) => ({
            traitId: builderState.animatedTraits[i].baseId,
            variants: count,
            cycles: lcm / count
          }));
          syncInfo = {
            totalFrames,
            syncMode,
            lcm,
            cycles,
            message: `‚úÖ Sincronizaci√≥n perfecta: ${lcm} frames (MCM ‚â§ ${MAX_FRAMES_LCM})`
          };
        } else {
          totalFrames = maxVariants;
          syncMode = 'cycled';
          syncInfo = {
            totalFrames,
            syncMode,
            lcm,
            message: `‚ö†Ô∏è MCM (${lcm}) > ${MAX_FRAMES_LCM}: usando ${totalFrames} frames (con ciclos)`
          };
        }
      }
      
      return syncInfo;
    }
    
    // Actualizar total frames basado en animated traits usando l√≥gica MCM
    function updateTotalFramesFromAnimatedTraits() {
      if (!builderState.animatedTraits || !Array.isArray(builderState.animatedTraits)) {
        return;
      }
      
      const syncInfo = calculateSyncInfo();
      
      if (syncInfo && syncInfo.totalFrames > 0) {
        // Actualizar total frames con el valor calculado
        if (syncInfo.totalFrames > builderState.totalFrames || builderState.frames.length === 0) {
          builderState.totalFrames = syncInfo.totalFrames;
          document.getElementById('total-frames').value = builderState.totalFrames;
        }
      }
    }
    
    // Animated traits management functions
    function addAnimatedTrait() {
      // Asegurar que animatedTraits existe
      if (!builderState.animatedTraits) {
        builderState.animatedTraits = [];
      }
      builderState.animatedTraits.push({ baseId: '', variants: [], delay: 500 });
      renderAnimatedTraits();
      updateURL();
      saveState();
    }
    
    async function updateAnimatedTraitBase(index, value) {
      builderState.animatedTraits[index].baseId = value;
      builderState.animatedTraits[index].variants = []; // Reset variants when base changes
      
      // Re-render inmediatamente para mostrar "Detecting..."
      renderAnimatedTraits();
      
      // Si hay un valor, detectar variantes autom√°ticamente
      if (value && value.trim()) {
        await detectAnimatedVariants(index);
      } else {
        updateURL();
        saveState();
      }
    }
    
    function updateAnimatedTraitDelay(index, value) {
      builderState.animatedTraits[index].delay = Math.max(10, Math.min(5000, value || 500));
      renderAnimatedTraits();
      updateURL();
      saveState();
    }
    
    function removeAnimatedTrait(index) {
      builderState.animatedTraits.splice(index, 1);
      renderAnimatedTraits();
      updateURL();
      saveState();
    }
    
    // Render frames
    function renderFrames() {
      const container = document.getElementById('frames-list');
      container.innerHTML = '';
      
      builderState.frames.forEach((frame, index) => {
        const frameConfig = builderState.frameConfigs[frame.id] || { frames: [], movements: {} };
        const selectedFrames = frameConfig.frames || [];
        
        const item = document.createElement('div');
        item.className = 'list-item';
        item.style.flexDirection = 'column';
        item.style.alignItems = 'stretch';
        item.innerHTML = `
          <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
            <span class="drag-handle">‚ò∞</span>
            <input type="text" value="${frame.id}" placeholder="Trait ID" 
                   onchange="updateFrameId(${index}, this.value)" style="flex: 1;">
            <input type="number" value="${frame.delay || 500}" placeholder="Delay (ms)" min="10" max="5000"
                   onchange="updateFrameDelay(${index}, parseInt(this.value))" style="width: 120px;">
            <button class="btn btn-secondary btn-small btn-icon" onclick="duplicateFrame(${index})">üìã</button>
            <button class="btn btn-danger btn-small btn-icon" onclick="removeFrame(${index})">√ó</button>
          </div>
          ${frame.id ? `
            <div class="trait-frame-config">
              <div class="trait-frame-config-title">Appears in frames:</div>
              <div class="quick-select-buttons">
                <button class="quick-select-btn" onclick="selectAllFrames('${frame.id}')">All</button>
                <button class="quick-select-btn" onclick="selectNoFrames('${frame.id}')">None</button>
                <button class="quick-select-btn" onclick="selectFirstHalf('${frame.id}')">First Half</button>
                <button class="quick-select-btn" onclick="selectSecondHalf('${frame.id}')">Second Half</button>
              </div>
              <div class="frame-selector" id="frame-selector-${frame.id}">
                ${generateFrameCheckboxes(frame.id, selectedFrames)}
              </div>
            </div>
          ` : ''}
        `;
        container.appendChild(item);
      });
    }
    
    // Generate frame checkboxes
    function generateFrameCheckboxes(traitId, selectedFrames) {
      let html = '';
      for (let i = 1; i <= builderState.totalFrames; i++) {
        const isSelected = selectedFrames.includes(i);
        html += `
          <label class="frame-checkbox ${isSelected ? 'selected' : ''}">
            <input type="checkbox" ${isSelected ? 'checked' : ''} 
                   onchange="toggleFrameForTrait('${traitId}', ${i}, this.checked)">
            ${i}
          </label>
        `;
      }
      return html;
    }
    
    // Frame selection functions
    function toggleFrameForTrait(traitId, frameNum, selected) {
      if (!builderState.frameConfigs[traitId]) {
        builderState.frameConfigs[traitId] = { frames: [], movements: {} };
      }
      
      const frames = builderState.frameConfigs[traitId].frames;
      if (selected) {
        if (!frames.includes(frameNum)) {
          frames.push(frameNum);
          frames.sort((a, b) => a - b);
        }
      } else {
        const index = frames.indexOf(frameNum);
        if (index > -1) {
          frames.splice(index, 1);
        }
      }
      
      renderFrames();
      updateURL();
      saveState();
    }
    
    function selectAllFrames(traitId) {
      if (!builderState.frameConfigs[traitId]) {
        builderState.frameConfigs[traitId] = { frames: [], movements: {} };
      }
      builderState.frameConfigs[traitId].frames = Array.from({length: builderState.totalFrames}, (_, i) => i + 1);
      renderFrames();
      updateURL();
      saveState();
    }
    
    function selectNoFrames(traitId) {
      if (!builderState.frameConfigs[traitId]) {
        builderState.frameConfigs[traitId] = { frames: [], movements: {} };
      }
      builderState.frameConfigs[traitId].frames = [];
      renderFrames();
      updateURL();
      saveState();
    }
    
    function selectFirstHalf(traitId) {
      if (!builderState.frameConfigs[traitId]) {
        builderState.frameConfigs[traitId] = { frames: [], movements: {} };
      }
      const half = Math.ceil(builderState.totalFrames / 2);
      builderState.frameConfigs[traitId].frames = Array.from({length: half}, (_, i) => i + 1);
      renderFrames();
      updateURL();
      saveState();
    }
    
    function selectSecondHalf(traitId) {
      if (!builderState.frameConfigs[traitId]) {
        builderState.frameConfigs[traitId] = { frames: [], movements: {} };
      }
      const half = Math.ceil(builderState.totalFrames / 2);
      builderState.frameConfigs[traitId].frames = Array.from({length: builderState.totalFrames - half}, (_, i) => i + half + 1);
      renderFrames();
      updateURL();
      saveState();
    }
    
    function updateTotalFrames(value) {
      builderState.totalFrames = Math.max(1, Math.min(100, value || 10));
      document.getElementById('total-frames').value = builderState.totalFrames;
      renderFrames();
      renderFixedTraits();
      updateURL();
      saveState();
    }
    
    // Render movements
    function renderMovements() {
      const container = document.getElementById('movements-list');
      container.innerHTML = '';
      
      builderState.movements.forEach((move, index) => {
        const item = document.createElement('div');
        item.className = 'movement-config';
        item.innerHTML = `
          <div class="movement-header">
            <div class="movement-toggle">
              <div class="toggle-switch ${move.enabled ? 'active' : ''}" 
                   onclick="toggleMovement(${index})"></div>
              <strong>${getMovementLabel(move)}</strong>
            </div>
            <button class="btn btn-danger btn-small" onclick="removeMovement(${index})">Remove</button>
          </div>
          <div style="display: ${move.enabled ? 'block' : 'none'};" id="movement-${index}-config">
            <div class="form-group">
              <label>Target Layer:</label>
              <select onchange="updateMovementLayer(${index}, this.value)">
                <option value="base" ${move.layerType === 'base' ? 'selected' : ''}>Base Skin</option>
                <option value="variable" ${move.layerType === 'variable' ? 'selected' : ''}>Variable (All Frames)</option>
                ${builderState.fixed.map((t, i) => 
                  `<option value="fixed.${t.id}" ${move.layerType === 'fixed' && move.layerId === t.id ? 'selected' : ''}>
                    Fixed: ${t.id || 'New'}
                  </option>`
                ).join('')}
              </select>
            </div>
            ${move.layerType === 'fixed' ? `
              <div class="form-group">
                <label>Fixed Trait ID:</label>
                <input type="text" value="${move.layerId || ''}" placeholder="Trait ID" 
                       onchange="updateMovementLayerId(${index}, this.value)">
              </div>
            ` : ''}
            <div class="form-group">
              <label>Movement Type:</label>
              <select onchange="updateMovementType(${index}, this.value)">
                <option value="circular" ${move.type === 'circular' ? 'selected' : ''}>Circular</option>
                <option value="bounce" ${move.type === 'bounce' ? 'selected' : ''}>Bounce</option>
                <option value="linear" ${move.type === 'linear' ? 'selected' : ''}>Linear</option>
                <option value="shake" ${move.type === 'shake' ? 'selected' : ''}>Shake</option>
                <option value="orbit" ${move.type === 'orbit' ? 'selected' : ''}>Orbit</option>
                <option value="zoom" ${move.type === 'zoom' ? 'selected' : ''}>Zoom</option>
              </select>
            </div>
            ${getMovementParamsHTML(move, index)}
          </div>
        `;
        container.appendChild(item);
      });
    }
    
    function getMovementLabel(move) {
      const layer = move.layerId ? `${move.layerType}.${move.layerId}` : move.layerType;
      return `${layer} - ${move.type}`;
    }
    
    function getMovementParamsHTML(move, index) {
      switch (move.type) {
        case 'circular':
          return `
            <div class="form-group">
              <label>Radius (px):</label>
              <input type="number" value="${move.params[0] || 50}" min="1" max="150"
                     onchange="updateMovementParam(${index}, 0, this.value)">
            </div>
            <div class="form-group">
              <label>Rotations:</label>
              <input type="number" value="${move.params[1] || 2}" min="0.1" max="10" step="0.1"
                     onchange="updateMovementParam(${index}, 1, this.value)">
            </div>
          `;
        case 'bounce':
          return `
            <div class="form-group">
              <label>Direction:</label>
              <select onchange="updateMovementParam(${index}, 0, this.value)">
                <option value="x" ${move.params[0] === 'x' ? 'selected' : ''}>Horizontal (X)</option>
                <option value="y" ${move.params[0] === 'y' ? 'selected' : ''}>Vertical (Y)</option>
              </select>
            </div>
            <div class="form-group">
              <label>Distance (px):</label>
              <input type="number" value="${move.params[1] || 40}" min="1" max="200"
                     onchange="updateMovementParam(${index}, 1, this.value)">
            </div>
            <div class="form-group">
              <label>Bounces:</label>
              <input type="number" value="${move.params[2] || 3}" min="1" max="10"
                     onchange="updateMovementParam(${index}, 2, this.value)">
            </div>
          `;
        case 'linear':
          return `
            <div class="form-group">
              <label>X (px):</label>
              <input type="number" value="${move.params.find(p => p === 'x') ? move.params[move.params.indexOf('x') + 1] : 0}" 
                     onchange="updateLinearMovement(${index}, 'x', this.value)">
            </div>
            <div class="form-group">
              <label>Y (px):</label>
              <input type="number" value="${move.params.find(p => p === 'y') ? move.params[move.params.indexOf('y') + 1] : 0}" 
                     onchange="updateLinearMovement(${index}, 'y', this.value)">
            </div>
          `;
        case 'shake':
          return `
            <div class="form-group">
              <label>Intensity (px):</label>
              <input type="number" value="${move.params[0] || 10}" min="1" max="50"
                     onchange="updateMovementParam(${index}, 0, this.value)">
            </div>
            <div class="form-group">
              <label>Speed:</label>
              <select onchange="updateMovementParam(${index}, 1, this.value)">
                <option value="slow" ${move.params[1] === 'slow' ? 'selected' : ''}>Slow</option>
                <option value="normal" ${!move.params[1] || move.params[1] === 'normal' ? 'selected' : ''}>Normal</option>
                <option value="fast" ${move.params[1] === 'fast' ? 'selected' : ''}>Fast</option>
              </select>
            </div>
          `;
        case 'orbit':
          return `
            <div class="form-group">
              <label>Radius (px):</label>
              <input type="number" value="${move.params[0] || 80}" min="1" max="150"
                     onchange="updateMovementParam(${index}, 0, this.value)">
            </div>
            <div class="form-group">
              <label>Rotations:</label>
              <input type="number" value="${move.params[1] || 2}" min="0.1" max="10" step="0.1"
                     onchange="updateMovementParam(${index}, 1, this.value)">
            </div>
          `;
        case 'zoom':
          return `
            <div class="form-group">
              <label>Min Scale:</label>
              <input type="number" value="${move.params[0] || 0.5}" min="0.1" max="1" step="0.1"
                     onchange="updateMovementParam(${index}, 0, this.value)">
            </div>
            <div class="form-group">
              <label>Max Scale:</label>
              <input type="number" value="${move.params[1] || 1.5}" min="1" max="3" step="0.1"
                     onchange="updateMovementParam(${index}, 1, this.value)">
            </div>
          `;
        default:
          return '';
      }
    }
    
    // Fixed traits management functions
    function addFixedTrait() {
      builderState.fixed.push({ id: '' });
      renderFixedTraits();
      updateURL();
      saveState();
    }
    
    function updateFixedTrait(index, value) {
      const oldId = builderState.fixed[index].id;
      builderState.fixed[index].id = value;
      
      // Si cambi√≥ el ID, migrar la configuraci√≥n
      if (oldId && oldId !== value && builderState.frameConfigs[oldId]) {
        builderState.frameConfigs[value] = builderState.frameConfigs[oldId];
        delete builderState.frameConfigs[oldId];
      }
      
      renderFixedTraits();
      updateURL();
      saveState();
    }
    
    function removeFixedTrait(index) {
      builderState.fixed.splice(index, 1);
      renderFixedTraits();
      updateURL();
      saveState();
    }
    
    // Frames management functions
    function addFrame() {
      builderState.frames.push({ id: '', delay: 500 });
      renderFrames();
      updateURL();
      saveState();
    }
    
    function updateFrameId(index, value) {
      const oldId = builderState.frames[index].id;
      builderState.frames[index].id = value;
      
      // Si cambi√≥ el ID, migrar la configuraci√≥n
      if (oldId && oldId !== value && builderState.frameConfigs[oldId]) {
        builderState.frameConfigs[value] = builderState.frameConfigs[oldId];
        delete builderState.frameConfigs[oldId];
      }
      
      renderFrames();
      updateURL();
      saveState();
    }
    
    function updateFrameDelay(index, value) {
      builderState.frames[index].delay = Math.max(10, Math.min(5000, value || 500));
      renderFrames();
      updateURL();
      saveState();
    }
    
    function duplicateFrame(index) {
      const frame = { ...builderState.frames[index] };
      builderState.frames.splice(index + 1, 0, frame);
      renderFrames();
      updateURL();
      saveState();
    }
    
    function removeFrame(index) {
      builderState.frames.splice(index, 1);
      renderFrames();
      updateURL();
      saveState();
    }
    
    // Movements management functions
    function addMovement() {
      // Si hay traits fijos, usar el primero por defecto, sino variable
      let defaultLayerType = 'variable';
      let defaultLayerId = null;
      
      if (builderState.fixed.length > 0) {
        defaultLayerType = 'fixed';
        defaultLayerId = builderState.fixed[0].id;
      }
      
      builderState.movements.push({
        layerType: defaultLayerType,
        layerId: defaultLayerId,
        type: 'circular',
        params: ['50', '2'],
        enabled: true
      });
      
      renderMovements();
      updateURL();
      saveState();
    }
    
    function toggleMovement(index) {
      builderState.movements[index].enabled = !builderState.movements[index].enabled;
      renderMovements();
      updateURL();
      saveState();
    }
    
    function updateMovementLayer(index, layerSpec) {
      const parts = layerSpec.split('.');
      const layerType = parts[0];
      const layerId = parts.length > 1 ? parts[1] : null;
      
      builderState.movements[index].layerType = layerType;
      builderState.movements[index].layerId = layerId;
      
      renderMovements();
      updateURL();
      saveState();
    }
    
    function updateMovementLayerId(index, layerId) {
      builderState.movements[index].layerId = layerId;
      renderMovements();
      updateURL();
      saveState();
    }
    
    function updateMovementType(index, type) {
      builderState.movements[index].type = type;
      // Reset params seg√∫n tipo
      switch (type) {
        case 'circular':
          builderState.movements[index].params = ['50', '2'];
          break;
        case 'bounce':
          builderState.movements[index].params = ['y', '40', '3'];
          break;
        case 'linear':
          builderState.movements[index].params = ['x', '0', 'y', '0'];
          break;
        case 'shake':
          builderState.movements[index].params = ['10', 'normal'];
          break;
        case 'orbit':
          builderState.movements[index].params = ['80', '2'];
          break;
        case 'zoom':
          builderState.movements[index].params = ['0.5', '1.5'];
          break;
      }
      renderMovements();
      updateURL();
      saveState();
    }
    
    function updateMovementParam(index, paramIndex, value) {
      builderState.movements[index].params[paramIndex] = value;
      updateURL();
      saveState();
    }
    
    function updateLinearMovement(index, axis, value) {
      const params = builderState.movements[index].params;
      const axisIndex = params.indexOf(axis);
      if (axisIndex >= 0) {
        params[axisIndex + 1] = value;
      } else {
        params.push(axis, value);
      }
      updateURL();
      saveState();
    }
    
    function removeMovement(index) {
      builderState.movements.splice(index, 1);
      renderMovements();
      updateURL();
      saveState();
    }
    
    // Generate URL
    function updateURL() {
      const params = new URLSearchParams();
      
      if (builderState.method) params.set('method', builderState.method);
      if (builderState.base) params.set('base', builderState.base);
      
      // Fixed traits - solo incluir los que NO tienen configuraci√≥n de frames
      // (si tienen configuraci√≥n de frames, se usar√°n en el par√°metro frames)
      const activeFixed = builderState.fixed.filter(t => {
        if (!t.id) return false;
        const config = builderState.frameConfigs[t.id];
        // Solo incluir si no tiene configuraci√≥n de frames o si tiene frames pero tambi√©n debe aparecer fijo
        // Por ahora, si tiene configuraci√≥n de frames, no lo incluimos en fixed
        return !config || !config.frames || config.frames.length === 0;
      });
      if (activeFixed.length > 0) {
        params.set('fixed', activeFixed.map(t => t.id).join(','));
      }
      
      // Animated Traits - usar formato corto "animated"
      if (builderState.animatedTraits && Array.isArray(builderState.animatedTraits)) {
        const activeAnimated = builderState.animatedTraits.filter(animTrait => {
          return animTrait.baseId && animTrait.variants && animTrait.variants.length > 0;
        });
        
        if (activeAnimated.length > 0) {
          // Usar formato corto: animated=1167:500,1166:300
          const animatedParams = activeAnimated.map(animTrait => {
            return `${animTrait.baseId}:${animTrait.delay || 500}`;
          });
          params.set('animated', animatedParams.join(','));
        }
      }
      
      // Variable frames - generar frames basados en la configuraci√≥n
      // Si un trait aparece en m√∫ltiples frames, generar m√∫ltiples entradas
      const frameEntries = [];
      
      // SEGUNDO: Buscar configuraci√≥n de frames en Variable Traits
      const hasVariableFrameConfig = builderState.frames.some(f => {
        if (!f.id) return false;
        const config = builderState.frameConfigs[f.id];
        return config && config.frames && config.frames.length > 0;
      });
      
      // TERCERO: Si no hay en Variable Traits, buscar en Fixed Traits
      const hasFixedFrameConfig = !hasVariableFrameConfig && builderState.fixed.some(t => {
        if (!t.id) return false;
        const config = builderState.frameConfigs[t.id];
        return config && config.frames && config.frames.length > 0;
      });
      
      // Calcular el frame inicial para Variable/Fixed traits (despu√©s de animated traits)
      const animatedFramesCount = frameEntries.length;
      
      if (hasVariableFrameConfig || hasFixedFrameConfig) {
        // Usar configuraci√≥n de frames: generar un frame por cada frame n√∫mero donde hay un trait
        // Empezar despu√©s de los animated traits
        for (let frameNum = animatedFramesCount + 1; frameNum <= builderState.totalFrames; frameNum++) {
          // Primero buscar en Variable Traits
          let traitForFrame = builderState.frames.find(f => {
            if (!f.id) return false;
            const config = builderState.frameConfigs[f.id];
            const frames = config?.frames || [];
            return frames.includes(frameNum);
          });
          
          // Si no se encuentra en Variable Traits, buscar en Fixed Traits
          if (!traitForFrame) {
            traitForFrame = builderState.fixed.find(t => {
              if (!t.id) return false;
              const config = builderState.frameConfigs[t.id];
              const frames = config?.frames || [];
              return frames.includes(frameNum);
            });
            
            // Si encontramos un fixed trait, crear un objeto similar a un frame
            if (traitForFrame) {
              traitForFrame = {
                id: traitForFrame.id,
                delay: 500 // Default delay para fixed traits
              };
            }
          }
          
          if (traitForFrame) {
            frameEntries.push({
              id: traitForFrame.id,
              delay: traitForFrame.delay || 500,
              frameNum: frameNum
            });
          } else {
            // Si no hay trait para este frame, usar el √∫ltimo trait o el primero como fallback
            const fallbackTrait = builderState.frames.find(f => f.id) || 
                                 builderState.fixed.find(t => t.id) || 
                                 builderState.frames[0];
            if (fallbackTrait && fallbackTrait.id) {
              frameEntries.push({
                id: fallbackTrait.id,
                delay: fallbackTrait.delay || 500,
                frameNum: frameNum
              });
            }
          }
        }
      } else {
        // M√©todo antiguo: un frame por cada trait (compatibilidad)
        // Primero Variable Traits
        builderState.frames
          .filter(f => f.id)
          .forEach(f => {
            frameEntries.push({
              id: f.id,
              delay: f.delay || 500,
              frameNum: null
            });
          });
        
        // Si no hay Variable Traits, usar Fixed Traits como frames
        if (frameEntries.length === 0) {
          builderState.fixed
            .filter(t => t.id)
            .forEach(t => {
              frameEntries.push({
                id: t.id,
                delay: 500,
                frameNum: null
              });
            });
        }
      }
      
      // Solo a√±adir frames si hay frameEntries Y no hay animated traits activos
      const hasActiveAnimated = builderState.animatedTraits && 
        builderState.animatedTraits.some(at => at.baseId && at.variants && at.variants.length > 0);
      
      if (frameEntries.length > 0 && !hasActiveAnimated) {
        params.set('frames', frameEntries
          .map(f => `${f.id}:${f.delay}`)
          .join(','));
      }
      
      // Movements - incluir movimientos que est√©n habilitados
      if (builderState.movements.length > 0) {
        builderState.movements
          .filter(m => m.enabled)
          .forEach(move => {
            const layerSpec = move.layerId 
              ? `${move.layerType}.${move.layerId}`
              : move.layerType;
            const moveStr = [layerSpec, move.type, ...move.params].join(':');
            params.append('move', moveStr);
          });
      }
      
      // A√±adir AdrianZERO tokenId si existe (solo v3)
      if (builderState.version === 'v3' && builderState.adrianZeroTokenId) {
        params.set('adrianzero', builderState.adrianZeroTokenId);
      }
      
      // A√±adir configuraci√≥n de bounce si est√° habilitada
      if (builderState.bounceConfig && builderState.bounceConfig.enabled) {
        const bc = builderState.bounceConfig;
        params.set('bounce', 'true');
        params.set('bounceDir', bc.direction);
        params.set('bounceDist', bc.distance.toString());
        params.set('bounceCount', bc.bounces.toString());
        params.set('bounceFrames', bc.frames.toString());
        params.set('bounceDelay', bc.delay.toString());
      }
      
      // Select endpoint based on version
      let endpoint = 'test-gif-simple';
      if (builderState.version === 'v2') {
        endpoint = 'test-gif-simple-v2';
      } else if (builderState.version === 'v3') {
        endpoint = 'test-gif-simple-v3';
      }
      
      const url = `https://adrianlab.vercel.app/api/${endpoint}?${params.toString()}`;
      document.getElementById('url-display').textContent = url;
    }
    
    // Copy URL
    function copyURL() {
      const url = document.getElementById('url-display').textContent;
      navigator.clipboard.writeText(url).then(() => {
        showMessage('URL copied to clipboard', 'success');
      }).catch(() => {
        showMessage('Error copying URL', 'error');
      });
    }
    
    // Open URL
    function openURL() {
      const url = document.getElementById('url-display').textContent;
      window.open(url, '_blank');
    }
    
    // Generate preview
    async function generatePreview() {
      const previewArea = document.getElementById('preview-area');
      const previewInfo = document.getElementById('preview-info');
      
      // Calcular total de frames (frames normales + animated traits)
      const totalAnimatedFrames = (builderState.animatedTraits || []).reduce((sum, at) => {
        return sum + (at.variants && at.variants.length > 0 ? at.variants.length : 0);
      }, 0);
      const hasFrames = builderState.frames.length > 0 || totalAnimatedFrames > 0;
      
      // Validate
      if (!hasFrames) {
        showMessage('Add at least one frame or animated trait', 'error');
        return;
      }
      
      if (builderState.frames.some(f => !f.id)) {
        showMessage('All frames must have a trait ID', 'error');
        return;
      }
      
      previewArea.innerHTML = '<div class="loading"></div><p style="margin-top: 10px;">Generating preview...</p>';
      previewInfo.style.display = 'none';
      
      try {
        const url = document.getElementById('url-display').textContent;
        const response = await fetch(url);
        
        if (!response.ok) {
          throw new Error(`Error ${response.status}: ${response.statusText}`);
        }
        
        const blob = await response.blob();
        const imageUrl = URL.createObjectURL(blob);
        
        previewArea.innerHTML = `<img src="${imageUrl}" alt="Preview GIF">`;
        
        // Show information
        const frameCount = response.headers.get('X-Frame-Count') || builderState.frames.length;
        const duration = response.headers.get('X-Duration-Ms') || 'N/A';
        const size = response.headers.get('X-Size-KB') || 'N/A';
        const layers = response.headers.get('X-Layers-Per-Frame') || 
          (1 + builderState.fixed.length + 1);
        
        document.getElementById('info-frames').textContent = frameCount;
        document.getElementById('info-duration').textContent = `${duration}ms`;
        document.getElementById('info-size').textContent = `${size} KB`;
        document.getElementById('info-layers').textContent = layers;
        previewInfo.style.display = 'block';
        
        showMessage('Preview generated successfully', 'success');
      } catch (error) {
        previewArea.innerHTML = `<p style="color: #ef4444;">Error: ${error.message}</p>`;
        showMessage(`Error generating preview: ${error.message}`, 'error');
      }
    }
    
    // Show message
    function showMessage(text, type) {
      const area = document.getElementById('message-area');
      const msg = document.createElement('div');
      msg.className = type === 'error' ? 'error' : 'success';
      msg.textContent = text;
      area.innerHTML = '';
      area.appendChild(msg);
      
      setTimeout(() => {
        msg.remove();
      }, 5000);
    }
    
    // Event listeners
    document.getElementById('version').addEventListener('change', (e) => {
      builderState.version = e.target.value;
      updateURL();
      saveState();
    });
    
    document.getElementById('method').addEventListener('change', (e) => {
      builderState.method = e.target.value;
      updateURL();
      saveState();
    });
    
    document.getElementById('base').addEventListener('change', (e) => {
      builderState.base = e.target.value;
      updateURL();
      saveState();
    });
    
    document.getElementById('total-frames').addEventListener('change', (e) => {
      updateTotalFrames(parseInt(e.target.value));
    });
    
    // Initialize
    loadState();
    // Asegurar que totalFrames tiene un valor por defecto
    if (!builderState.totalFrames) {
      builderState.totalFrames = 10;
    }
    if (!builderState.frameConfigs) {
      builderState.frameConfigs = {};
    }
    updateURL();
  </script>
</body>
</html>

